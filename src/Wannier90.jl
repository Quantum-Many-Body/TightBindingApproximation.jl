module Wannier90

export readhamiltonian

"""
    readhamiltonian(path::AbstractString, prefix::AbstractString="wannier90") -> Tuple{Dict{NTuple{3, Int}, ComplexF64}, Dict{NTuple{3, Int}, Int}}

Read the hamiltonian and degeneracies from the "_hr.dat" file generated by Wannier90.
"""
function readhamiltonian(path::AbstractString, prefix::AbstractString="wannier90")
    lines = open(readlines, path*"\\"*prefix*"_hr.dat", "r")
    num_wan = parse(Int, lines[2])
    nrpts = parse(Int, lines[3])
    degeneracies = Int[]
    start = 0
    for i in 4:length(lines)
        append!(degeneracies, parse(Int, degeneracy) for degeneracy in split(lines[i]))
        if length(degeneracies) == nrpts
            start = i+1
            break
        end
        length(degeneracies)>nrpts && error("readhamiltonian error: too many degeneracies for the Wigner-Seitz points of the superlattice.")
    end
    index = 1
    ham = Dict{NTuple{3, Int}, Matrix{ComplexF64}}()
    deg = Dict{NTuple{3, Int}, Int}()
    for k in start:length(lines)
        info = split(lines[k])
        point = (parse(Int, info[1]), parse(Int, info[2]), parse(Int, info[3]))
        i, j = parse(Int, info[4]), parse(Int, info[5])
        value = parse(Float64, info[6]) + 1im*parse(Float64, info[7])
        if !haskey(ham, point)
            ham[point] = zeros(ComplexF64, num_wan, num_wan)
            deg[point] = degeneracies[index]
            index += 1
        end
        ham[point][i, j] = value/deg[point]
    end
    for point in keys(ham)
        @assert haskey(ham, map(-, point)) "readhamiltonian error: did not find the inverse of point $(point)."
    end
    return ham
end

end